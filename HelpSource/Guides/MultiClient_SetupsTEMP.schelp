TITLE:: MultiClient_SetupsTEMP
SUMMARY:: Discussion of proposed differences in topic branch
CATEGORIES:: Guides
related:: Classes/ServerOptions, Classes/Server
KEYWORD:: server, multi-client

Note::
For now, this file discusses the topic branch server-fix-multiclient,
with demonstrations and tests. When the branch is merged, it will be removed,
and MultiClient_Setups remains as a guide.
::

section:: Multi client-server setups - discussion and tests

OSC communication between SC and its sound server offers many options for network music: Multiple computers can run both supercollider and associated sound servers.
Basic SC support for simple, symmetrical connection between these is currently buggy,
and this topic branch proposes bug fixes and obvious little improvements.

For clarity, the "server program" refers a running scsynth or supernova process.
The "server object" AKA "client" is the server's representation in sclang, such as Server.local, s, Server(\elsewhere, NetAddr("123.234.34.56")).

subsection:: How things work in current master, Jun 11 2017:

list::
## the server program gets a limit of maxLogins as boot parameters.
## by default, the server program sends back a free clientID when a new
	local or remote server object/client logs in.
## if the server object was given a clientID on creation,
	it keeps that clientID, to allow fixed clientID distribution.
	(This variant may be deprecated in the future.)
::

When more than one user plays on a given server,
some resources need to be shared:
list::
## permanent and temp nodeIDs (handled by s.nodeAllocator),
## internal control and audio bus channels (handled by s.audioBusAllocator, s.controlBusAllocator)
## buffer numbers (handled by s.bufferAllocator).
::

This is currently inconsistent and partially broken:

A. NodeIDAllocator works, but could be improved:
list::
## the limit to 32 users is arbitrary and could be removed
## the nodeID ranges use a binary mask which works fine,
  but makes it hard to identify which client a nodeID belongs to.
This could be made humanly readable (proposal below).
::


B. ContiguousBlockAllocator only works for clientID 0.
For other ids, the bus and buffer allocators fail with an error.

subsection:: Code examples and tests

code::
// This topic branch allows switching to the previous
// allocator classes for comparison and extended tests:
/*
// previous
Server.nodeAllocClass = NodeIDAllocator;
Server.busAllocClass = ContiguousBlockAllocator;
Server.bufferAllocClass = ContiguousBlockAllocator;

// proposed
Server.nodeAllocClass = ReadableNodeIDAllocator;
Server.busAllocClass = ContiguousBlockAllocatorWithOffset;
Server.bufferAllocClass = ContiguousBlockAllocatorWithOffset;
*/

// Show BUG in current master (was working on 3.8.0)
s.options.maxLogins = 8;
s.clientID = 2; // -> Error in Server:newBusAllocators

// same error when giving clientID on creation:
Server(\test, s.addr, s.options, clientID: 3);
::

subsection:: clientID and node allocation

A. Test the clientID method by hand

Note:: Setting clientID_ by hand is not recommended, as it can be confusing. Here it is only done for testing the method!

code::

s.options.maxLogins = 12;
// these work and post info
s.clientID_(1);
s.clientID_(2);
s.clientID_(15);
// guards against bad input - warns and keeps clientID
s.clientID_(nil);
s.clientID_("abc");
s.clientID_(16);
s.clientID_(-234);


// Recommended usage for fixed clientID:

s.options.maxLogins = 12;
z = Server(
	\remote4,
	// NetAddr("168.192.1.2", 57110), // netAddr of the other computer in my network
	NetAddr("127.0.0.1", 57105), // for testing, on this machine, different port
	s.options,		// make sure all remote servers have the same options
	4				// and if desired, set fixed client by some scheme
);

// now s knows it can change clientID from server login response
s.userSpecifiedClientID;
// and z knows to keep its clientID
z.userSpecifiedClientID;

::

subsection:: Separate defaultGroups and easy-to trace nodeIDs

In this branch, every client registering with a server should also have its own defaultGroup. Then all nodes belonging to a client are in its defaultGroup and can be specifically addressed, e.g. freeAll can release only one's own nodes, and not those of other clients on this server. In current master, all nodes are in a single shared  defaultGroup, and separate freeAll calls are impossible.
This is done in the ReadableNodeIDAllocator class.

code::

// ReadableNodeIDAllocator uses a decimal prefix:
// for cleintID 0, nothing changes:
s.clientID;
s.defaultGroupID; // for
s.defaultGroup;
// for server z:
z.clientID; 		// 4
z.defaultGroupID; 	// 400000001
z.defaultGroup;		// Group(400000001)
z.options.maxLogins	// 16

// s.defaultGroup is assumed to be 1 in many places in SC classes,
// so here are some tests whether synth creation works everywhere:
z.defaultGroup;
z.defaultGroupID;
z.asGroup;
z.asTarget;

// temp nodeIDs readably belong to clientID 4, starting with 4...1000
5.do { z.nextNodeID.postln };
5.do { s.nextNodeID.postln };


// test 4 ways of making sounds:
z.boot;
z.plotTree;
Server.default = z;

// Synth
x = Synth(\default, nil, z);
x.release;

x = { Dust.ar(10!2).lag(0.002) }.play(z);
x.release(2)

(dur: 4, server: z).play;

// JITLib nodeproxies
Ndef(\x, { Dust.ar(10 ! 2) });
Ndef(\x).play;
Ndef(\x).filter(10, { |in| Ringz.ar(in, [600, 800], 0.03) }).play;
Ndef(\x).end(3);

// other nodeID tests here?

::

subsection:: Bus channels and buffers have fully independent number ranges.

The proposed new class ContiguousBlockAllocatorWithOffset adds an offset for the overall range of numbers, which fixes the limitation to clientID 0 only. It is quite close to ContiguousBlockAllocator and I would vote for merging it into that class, maybe keeping the previous implementation as ContiguousBlockAllocatorPrev if desired.

code::
Server.default = Server.local;
// default clientID 0 behavior is identical:
// maybe recompile for clean state?
s.clientID;   // should be 0
s.options.maxLogins; // default 1

// you can set maxLogins_ by hand - not recommended, only for testing here:
s.options.maxLogins_(1);
s.options.numAudioBusChannels;
// then the newAllocators methods create allocator ranges accordingly
s.newBusAllocators;
s.audioBusAllocator.size; // 1020 buses to allocate

//  set maxLogins_ to 12 by hand - not recommended, only for testing here:
s.options.maxLogins_(12);
s.newBusAllocators; // 85 = 1020 / 12 buses to allocate.
s.audioBusAllocator.size;
3.collect { Bus.audio(s, 2) };
// 1365 control buses to allocate, starting at 0
s.controlBusAllocator.size;
3.collect { Bus.control(s, 2) };

// switch default server for testing
Server.default = z;

// audio bus range starts at 344 : 4 + (85 * 4)
3.collect { Bus.audio(s, 2) };
// control bus range starts at 5460: 1365 * 4
3.collect { Bus.control(s, 2) };

// add more bus alloc tests here

Server.local.bufferAllocator.size;
3.collect { Buffer(Server.local) }; // starts at 0

z.bufferAllocator.size;
3.collect { Buffer(z) }; // starts at 340

// add more buffer alloc tests here

::