TITLE:: MultiClient_Setups
SUMMARY:: How to handle clientIDs and id allocation in multi-client/server setups
CATEGORIES:: Guides
related:: Classes/ServerOptions, Classes/Server
KEYWORD:: server, multi-client

section:: Multi client-server setups - discussion and tests

OSC communication between SC and its sound server offers many options for network music: Multiple computers can run both supercollider and associated sound servers.
For clarity, the "server program" refers a running scsynth or supernova process. The "server object" AKA "client" is the server's representation in sclang, such as code::Server.local, s, Server(\elsewhere, NetAddr("123.234.56.78"))::.

subsection:: What are clientIDs for, and how do servers get them?

When more than one user plays on a given server,
some resources need to be shared between users/clients:
list::
## permanent and temporary nodeIDs (handled by s.nodeAllocator),
## private control and audio bus channels (handled by s.audioBusAllocator, s.controlBusAllocator)
## buffer numbers (handled by s.bufferAllocator).
::

In the simple default case, there is only a single user/client, who always gets clientID 0, and all the available resources (i.e. the full ranges of allocator numbers).

When multiple clients log in, this is what happens:
list::
## On startup, scsynth (the server program) gets a fixed limit of maxLogins.
## When a new local or remote server object/client registers on this scsynth process,
scsynth sends back the next free clientID.
## Exception: If the server object was given a clientID on creation, it keeps that clientID, to allow fixed clientID distribution. (This variant may become deprecated in the future.)
::

subsection:: Code examples and tests

A. Test the clientID method by hand

Note:: Setting clientID_ by hand is not recommended, as it can be confusing.
Here it is only done for testing the method!::

code::

s.options.maxLogins = 12;
// these work and post info
s.clientID_(1);
s.clientID_(2);
s.clientID_(11);
// guards against bad input - warns and keeps clientID
s.clientID_(nil);
s.clientID_("abc");
s.clientID_(16);
s.clientID_(-234);
// reset to default:
s.clientID_(0);


// Recommended usage for fixed clientIDs - set clientID on creation.

s.options.maxLogins = 12;

z = Server(
	\remote4,
	// NetAddr("168.192.1.2", 57110), // netAddr of the other computer in my network
	NetAddr("127.0.0.1", 57105), // for testing, on this machine, different port
	s.options,		// make sure all remote servers have the same options
	4				// and if desired, set fixed client by some scheme
);

// now s knows it can change clientID from server login response
// (because userSpecifiedClientID is false)
s.userSpecifiedClientID;
// and z knows to keep its clientID
z.userSpecifiedClientID;

::

subsection:: Separate defaultGroups and easy-to trace nodeIDs

Every client registering with a server has its own defaultGroup. All nodes belonging to one client are in its defaultGroup and can be specifically addressed, so e.g. freeAll can release only one's own nodes, and not those of other clients on this server.
For details, see the ReadableNodeIDAllocator class.

code::

// ReadableNodeIDAllocator uses a decimal prefix:
// for clientID 0, nothing changes:
s.clientID;
s.defaultGroup;
s.defaultGroupID;
// for server z:
z.clientID; 		// 4
z.defaultGroupID; 	// 400000001
z.defaultGroup;		// Group(400000001)
z.options.maxLogins	// 12

// s.defaultGroup is used often, and can be looked up in many ways:
z.defaultGroup;
z.defaultGroupID;
z.asGroup;
z.asTarget;

// temp nodeIDs readably belong to clientID 4, starting with 4...1000
5.do { z.nextNodeID.postln };
5.do { s.nextNodeID.postln };

// whenever an accessible sound process is created, it gets a nodeID;
// here are four different ways to create sounds, and see their nodeIDs:
z.boot;
z.plotTree;

Server.default = z;

// Synth
x = Synth(\default, nil);
x.release;

x = { Dust.ar(10!2).lag(0.002) }.play(z);
x.release(2);

(dur: 4, server: z).play;

// JITLib nodeproxies
Ndef(\x, { Dust.ar(10 ! 2) });
Ndef(\x).play;
Ndef(\x).filter(10, { |in| Ringz.ar(in, [600, 800], 0.03) }).play;
Ndef(\x).end(3);

// add more nodeID usage examples here...

::

subsection:: Bus channels and buffers have fully independent number ranges.


The class ContiguousBlockAllocatorWithOffset adds an offset for the overall range of numbers, which fixes the limitation to clientID 0 only. It is quite close to ContiguousBlockAllocator and I would vote for merging it into that class, maybe keeping the previous implementation as ContiguousBlockAllocatorPrev if desired.

code::
// default clientID 0 behavior is identical:
Server.default = Server.local;
s.clientID;   // should be 0
s.options.maxLogins; // default 1

// you can set maxLogins_ by hand - not recommended, only for testing here:
s.options.maxLogins_(1);
s.options.numAudioBusChannels;
// then the newAllocators methods create allocator ranges accordingly
s.newBusAllocators;
s.audioBusAllocator.size; // 1020 buses to allocate

//  set maxLogins_ to 12 by hand - not recommended, only for testing here:
s.options.maxLogins_(12);
s.newBusAllocators; // 85 = 1020 / 12 buses to allocate.
s.audioBusAllocator.size;
3.collect { Bus.audio(s, 2) };
// 1365 control buses to allocate, starting at 0
s.controlBusAllocator.size;
3.collect { Bus.control(s, 2) };

// switch default server for testing
Server.default = z;

// audio bus range starts at 344 : 4 + (85 * 4)
3.collect { Bus.audio(s, 2) };
// control bus range starts at 5460: 1365 * 4
3.collect { Bus.control(s, 2) };

// add more bus alloc tests here...


Server.default = Server.local;
s.bufferAllocator.size;
3.collect { Buffer(Server.local) }; // starts at 0

z.bufferAllocator.size;
3.collect { Buffer(z) }; // starts at 340

// add more buffer alloc tests here...

::